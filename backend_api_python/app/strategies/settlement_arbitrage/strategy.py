# Settlement Arbitrage Strategy - Core Strategy Logic
# 结算价差套利策略 - 策略核心逻辑

"""
Core strategy implementation for the Settlement Price Arbitrage Strategy.

Strategy Logic:
1. Monitor price after 14:30
2. If price drops > threshold_1 (default 1%) from 14:30 base price → BUY (level 1)
3. If price drops > threshold_2 (default 2%) → ADD position (level 2)
4. Close all positions at next day's opening price
5. Risk management: daily loss limit, max drawdown, position limits
"""

from dataclasses import dataclass, field
from datetime import date, datetime, time, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional

from app.strategies.settlement_arbitrage.config import StrategyConfig, RiskConfig
from app.strategies.settlement_arbitrage.data_handler import MinuteBar
from app.strategies.settlement_arbitrage.vwap_calculator import VWAPCalculator
from app.utils.logger import get_logger

logger = get_logger(__name__)


class StrategyState(Enum):
    """Strategy state machine states."""
    IDLE = "idle"              # No position, waiting
    WATCHING = "watching"      # In watch period (14:30-15:00), monitoring prices
    POSITION_1 = "position_1"  # Holding level 1 position (drop > threshold_1)
    POSITION_2 = "position_2"  # Holding level 2 position (drop > threshold_2)
    CLOSING = "closing"        # Closing positions (next day open)


class SignalType(Enum):
    """Trading signal types."""
    BUY_L1 = "buy_level_1"       # Buy signal - level 1 (first entry)
    BUY_L2 = "buy_level_2"       # Buy signal - level 2 (add position)
    SELL_CLOSE = "sell_close"     # Sell signal - close all positions
    ALERT = "alert"              # Price alert (approaching threshold)


@dataclass
class Signal:
    """
    Trading signal generated by the strategy.
    
    Attributes:
        signal_type: Type of signal
        symbol: Contract code
        price: Signal price
        base_price: 14:30 base price
        drop_pct: Drop percentage from base price (negative = down)
        vwap: Current VWAP value (if available)
        level: Position level (1 or 2)
        quantity: Suggested quantity
        timestamp: Signal timestamp
    """
    signal_type: SignalType
    symbol: str
    price: float
    base_price: float
    drop_pct: float
    vwap: Optional[float] = None
    level: int = 1
    quantity: int = 1
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            'signal_type': self.signal_type.value,
            'symbol': self.symbol,
            'price': self.price,
            'base_price': self.base_price,
            'drop_pct': self.drop_pct,
            'vwap': self.vwap,
            'level': self.level,
            'quantity': self.quantity,
            'timestamp': self.timestamp.isoformat(),
        }


@dataclass
class SymbolState:
    """
    Per-symbol state tracking during strategy execution.
    
    Attributes:
        symbol: Contract code
        state: Current strategy state for this symbol
        base_price: Price at 14:30 (watch_start)
        current_vwap: Current real-time VWAP
        entry_prices: List of entry prices
        entry_quantities: List of entry quantities
        today_signals: Signals generated today
    """
    symbol: str
    state: StrategyState = StrategyState.IDLE
    base_price: Optional[float] = None
    current_vwap: Optional[float] = None
    entry_prices: List[float] = field(default_factory=list)
    entry_quantities: List[int] = field(default_factory=list)
    entry_levels: List[int] = field(default_factory=list)
    today_signals: List[Signal] = field(default_factory=list)
    
    def reset_daily(self):
        """Reset state for a new trading day."""
        self.state = StrategyState.IDLE
        self.base_price = None
        self.current_vwap = None
        self.entry_prices = []
        self.entry_quantities = []
        self.entry_levels = []
        self.today_signals = []
    
    @property
    def has_position(self) -> bool:
        """Check if there's an open position."""
        return self.state in (StrategyState.POSITION_1, StrategyState.POSITION_2)
    
    @property
    def total_quantity(self) -> int:
        """Get total position quantity."""
        return sum(self.entry_quantities)
    
    @property
    def avg_entry_price(self) -> float:
        """Get average entry price."""
        if not self.entry_prices:
            return 0.0
        total_cost = sum(p * q for p, q in zip(self.entry_prices, self.entry_quantities))
        total_qty = sum(self.entry_quantities)
        return total_cost / total_qty if total_qty > 0 else 0.0


class SettlementArbitrageStrategy:
    """
    Settlement Price Arbitrage Strategy - Full Version.
    
    This strategy exploits the difference between the closing price
    and the settlement price (VWAP) of Chinese stock index futures.
    
    When the price drops significantly after 14:30, it often reverts
    toward the VWAP by the next day's opening.
    
    Usage:
        config = StrategyConfig(symbols=["IM0", "IC0"])
        strategy = SettlementArbitrageStrategy(config)
        
        # For each minute bar in the watch period:
        signals = strategy.on_bar(bar)
        
        # At next day's open:
        close_signals = strategy.on_day_open(symbol, open_price)
    """
    
    def __init__(
        self,
        config: StrategyConfig,
        risk_config: Optional[RiskConfig] = None,
        vwap_calculator: Optional[VWAPCalculator] = None
    ):
        self.config = config
        self.risk_config = risk_config or RiskConfig()
        self.vwap_calculator = vwap_calculator or VWAPCalculator()
        
        # Per-symbol states
        self._symbol_states: Dict[str, SymbolState] = {}
        for symbol in config.symbols:
            self._symbol_states[symbol] = SymbolState(symbol=symbol)
        
        # Daily trading log
        self._daily_signals: List[Signal] = []
        self._current_date: Optional[date] = None
        
        # Alert tracking (avoid duplicate alerts)
        self._alert_sent: Dict[str, bool] = {}
    
    @property
    def state(self) -> Dict[str, str]:
        """Get current state of all symbols."""
        return {
            symbol: ss.state.value
            for symbol, ss in self._symbol_states.items()
        }
    
    def get_symbol_state(self, symbol: str) -> Optional[SymbolState]:
        """Get state for a specific symbol."""
        return self._symbol_states.get(symbol)
    
    def on_bar(self, bar: MinuteBar) -> List[Signal]:
        """
        Process a new minute bar.
        
        This is the main entry point called for each minute bar
        during trading hours.
        
        Args:
            bar: MinuteBar with current price data
            
        Returns:
            List of signals generated (may be empty)
        """
        signals = []
        symbol = bar.symbol
        
        # Initialize symbol state if not tracked
        if symbol not in self._symbol_states:
            # Check if it's a known symbol (might be full code like IM2503)
            matched = False
            for tracked_symbol in self.config.symbols:
                if bar.symbol.startswith(tracked_symbol[:2]):
                    symbol = tracked_symbol
                    matched = True
                    break
            if not matched:
                return signals
        
        ss = self._symbol_states.get(symbol)
        if ss is None:
            return signals
        
        current_time = bar.datetime.time()
        current_date = bar.datetime.date()
        
        # Day change detection
        if self._current_date != current_date:
            self._on_new_day(current_date)
        
        # Phase 1: Before watch period - wait
        if current_time < self.config.watch_start:
            return signals
        
        # Phase 2: Watch period starts - set base price
        if ss.base_price is None and current_time >= self.config.watch_start:
            ss.base_price = bar.close
            ss.state = StrategyState.WATCHING
            logger.info(
                f"Strategy [{symbol}]: base price set to {bar.close} at {bar.datetime}"
            )
        
        # Phase 3: Check entry conditions during watch period
        if self.config.watch_start <= current_time <= self.config.watch_end:
            entry_signals = self._check_entry_condition(ss, bar)
            signals.extend(entry_signals)
            
            # Also check for alerts
            alert_signal = self._check_alert_condition(ss, bar)
            if alert_signal:
                signals.append(alert_signal)
        
        # Update VWAP
        if self.vwap_calculator:
            vwap = self.vwap_calculator.update_realtime(
                symbol, bar.close, bar.volume
            )
            ss.current_vwap = vwap
        
        # Record signals
        for sig in signals:
            ss.today_signals.append(sig)
            self._daily_signals.append(sig)
        
        return signals
    
    def _check_entry_condition(
        self, ss: SymbolState, bar: MinuteBar
    ) -> List[Signal]:
        """
        Check if entry conditions are met.
        
        Entry logic:
        - Level 1: Drop > threshold_1 (default 1%) → buy position_size_1
        - Level 2: Drop > threshold_2 (default 2%) → add position_size_2
        
        Args:
            ss: Symbol state
            bar: Current minute bar
            
        Returns:
            List of entry signals
        """
        signals = []
        
        if ss.base_price is None or ss.base_price == 0:
            return signals
        
        # Calculate drop percentage
        drop_pct = (bar.close - ss.base_price) / ss.base_price
        
        # Level 1 entry: price dropped > threshold_1
        if (
            ss.state in (StrategyState.IDLE, StrategyState.WATCHING) and
            drop_pct <= -self.config.threshold_1
        ):
            signal = Signal(
                signal_type=SignalType.BUY_L1,
                symbol=ss.symbol,
                price=bar.close,
                base_price=ss.base_price,
                drop_pct=drop_pct,
                vwap=ss.current_vwap,
                level=1,
                quantity=self.config.position_size_1,
                timestamp=bar.datetime,
            )
            
            # Record entry
            ss.entry_prices.append(bar.close)
            ss.entry_quantities.append(self.config.position_size_1)
            ss.entry_levels.append(1)
            ss.state = StrategyState.POSITION_1
            
            signals.append(signal)
            logger.info(
                f"Strategy [{ss.symbol}]: BUY L1 signal at {bar.close}, "
                f"drop={drop_pct:.2%}, base={ss.base_price}"
            )
        
        # Level 2 entry: price dropped > threshold_2 (add to position)
        elif (
            ss.state == StrategyState.POSITION_1 and
            drop_pct <= -self.config.threshold_2
        ):
            signal = Signal(
                signal_type=SignalType.BUY_L2,
                symbol=ss.symbol,
                price=bar.close,
                base_price=ss.base_price,
                drop_pct=drop_pct,
                vwap=ss.current_vwap,
                level=2,
                quantity=self.config.position_size_2,
                timestamp=bar.datetime,
            )
            
            # Record entry
            ss.entry_prices.append(bar.close)
            ss.entry_quantities.append(self.config.position_size_2)
            ss.entry_levels.append(2)
            ss.state = StrategyState.POSITION_2
            
            signals.append(signal)
            logger.info(
                f"Strategy [{ss.symbol}]: BUY L2 signal at {bar.close}, "
                f"drop={drop_pct:.2%}, base={ss.base_price}"
            )
        
        return signals
    
    def _check_alert_condition(
        self, ss: SymbolState, bar: MinuteBar
    ) -> Optional[Signal]:
        """
        Check if price is approaching entry threshold (alert).
        
        Sends alert when drop reaches alert_threshold (default 0.8%).
        
        Args:
            ss: Symbol state
            bar: Current minute bar
            
        Returns:
            Alert signal, or None
        """
        if ss.base_price is None or ss.base_price == 0:
            return None
        
        # Only alert if not already in position
        if ss.state not in (StrategyState.IDLE, StrategyState.WATCHING):
            return None
        
        # Check if alert already sent today
        if self._alert_sent.get(ss.symbol, False):
            return None
        
        drop_pct = (bar.close - ss.base_price) / ss.base_price
        
        if drop_pct <= -self.config.alert_threshold:
            self._alert_sent[ss.symbol] = True
            return Signal(
                signal_type=SignalType.ALERT,
                symbol=ss.symbol,
                price=bar.close,
                base_price=ss.base_price,
                drop_pct=drop_pct,
                vwap=ss.current_vwap,
                timestamp=bar.datetime,
            )
        
        return None
    
    def on_day_open(
        self, symbol: str, open_price: float, timestamp: Optional[datetime] = None
    ) -> Optional[Signal]:
        """
        Handle next day's market open - close all positions.
        
        Args:
            symbol: Contract symbol
            open_price: Opening price
            timestamp: Open timestamp
            
        Returns:
            Close signal, or None if no position
        """
        ss = self._symbol_states.get(symbol)
        if ss is None or not ss.has_position:
            return None
        
        if timestamp is None:
            timestamp = datetime.now()
        
        # Generate close signal
        signal = Signal(
            signal_type=SignalType.SELL_CLOSE,
            symbol=symbol,
            price=open_price,
            base_price=ss.base_price or 0,
            drop_pct=0,  # Will be calculated by caller
            vwap=ss.current_vwap,
            level=0,
            quantity=ss.total_quantity,
            timestamp=timestamp,
        )
        
        logger.info(
            f"Strategy [{symbol}]: CLOSE signal at open price {open_price}, "
            f"avg_entry={ss.avg_entry_price:.2f}, qty={ss.total_quantity}"
        )
        
        # Update state
        ss.state = StrategyState.CLOSING
        ss.today_signals.append(signal)
        self._daily_signals.append(signal)
        
        return signal
    
    def _on_new_day(self, new_date: date):
        """
        Handle transition to a new trading day.
        
        Resets daily state and alert tracking.
        
        Args:
            new_date: The new trading date
        """
        logger.info(f"Strategy: new trading day {new_date}")
        self._current_date = new_date
        self._daily_signals = []
        self._alert_sent = {}
        
        # Reset VWAP calculator
        if self.vwap_calculator:
            self.vwap_calculator.reset_realtime()
        
        # Reset symbol states (but don't clear positions - they may carry over)
        for symbol, ss in self._symbol_states.items():
            if not ss.has_position:
                ss.reset_daily()
            else:
                # Keep position info but reset other daily state
                ss.base_price = None
                ss.current_vwap = None
                ss.today_signals = []
    
    def reset(self):
        """Fully reset the strategy to initial state."""
        for symbol in self._symbol_states:
            self._symbol_states[symbol] = SymbolState(symbol=symbol)
        self._daily_signals = []
        self._current_date = None
        self._alert_sent = {}
        if self.vwap_calculator:
            self.vwap_calculator.clear_cache()
    
    def get_monitor_data(self) -> Dict[str, Any]:
        """
        Get current strategy monitoring data for all symbols.
        
        Returns:
            Dictionary with per-symbol monitoring data
        """
        data = {
            'current_date': self._current_date.isoformat() if self._current_date else None,
            'symbols': {},
            'total_signals_today': len(self._daily_signals),
        }
        
        for symbol, ss in self._symbol_states.items():
            data['symbols'][symbol] = {
                'state': ss.state.value,
                'base_price': ss.base_price,
                'current_vwap': ss.current_vwap,
                'has_position': ss.has_position,
                'total_quantity': ss.total_quantity,
                'avg_entry_price': ss.avg_entry_price,
                'entry_levels': ss.entry_levels,
                'signals_today': len(ss.today_signals),
            }
        
        return data
    
    def get_today_signals(self) -> List[Dict[str, Any]]:
        """Get all signals generated today."""
        return [s.to_dict() for s in self._daily_signals]
